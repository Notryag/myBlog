### curry 函数柯里化

本质就是函数的复用,用函数来保持状态
> function 的length相当于必须形参的个数.有默认值的不算(例x={})

```js
function a(x, y) {
}

a.length//2
```

```js
var fn = curry(function (a, b, c) {
  return [a, b, c];
})
var curry = (fn, arr = []) => {
  return (...args) => {
    //判断参数总数是否和fn参数个数相等
    if ([...arr, ...args].length === fn.length) {
      return fn(...arr, ...args) //拓展参数，调用fn
    } else {
      return curry(fn, [...arr, ...args]) //迭代，传入现有的所有参数
    }
  }
}
```

节流函数
```js

function throttle(fn, delay) {
  var previous = 0;
  // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
  return function (...args) {
    var now = new Date()
    if (now - previous > delay) {
      fn.apply(this, args)
      previous = now;
    }
  }
  
}
```

防抖函数
```js
function debounce(fn, delay, immediate) {
  let timer = null;

  return function() {
    const context = this
    const args = arguments
    timer && clearTimeout(timer)
    if(immediate) {
      const doNow = !timer
      timer = setTimeout(() => {
        timer = null
      }, delay)
      doNow && fn.apply(context, args)
    }
    else {
      timer = setTimeout(() => {
        fn.apply(context, args)
      }, delay)
    }
  };
}
```

深拷贝
```js
function deepCopy (obj, cache=[]) {
  // 结束递归
  if (obj === null || typeof obj !== 'object') return obj

  // 缓存命中，说明存在循环引用的情况
  var hit = cache.filter(c => c.original === obj)[0];
  if (hit) return hit.copy;

  var copy = Array.isArray(obj) ? [] : {};
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach((key) => {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}


const deepCopy2 = function(obj, map = new WeakMap()) {
    if (typeof obj !== 'object' || obj === null) return obj // 判断非引用类型，直接返回 如果是null，直接返回

    if (map.has(obj)) return map.get(obj) // 如果已经存在，则直接返回

    const res = new obj.constructor() // 找到当前数据的构造函数，创建对象

    map.set(obj, res) // 将新建对象存起来，防止循环引用
    
    for(const i in obj) {
      res[i] = deepCopy(obj[i], map) // 递归拷贝
    }
    return res
  }
```