### curry 函数柯里化

本质就是函数的复用,用函数来保持状态
> function 的length相当于必须形参的个数.有默认值的不算(例x={})

```js
function a(x, y) {
}

a.length//2
```

```js
var fn = curry(function (a, b, c) {
  return [a, b, c];
})
var curry = (fn, arr = []) => {
  return (...args) => {
    //判断参数总数是否和fn参数个数相等
    if ([...arr, ...args].length === fn.length) {
      return fn(...arr, ...args) //拓展参数，调用fn
    } else {
      return curry(fn, [...arr, ...args]) //迭代，传入现有的所有参数
    }
  }
}
```

节流函数
```js

function throttle(fn, delay) {
  var previous = 0;
  // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
  return function (...args) {
    var now = new Date()
    if (now - previous > delay) {
      fn.apply(this, args)
      previous = now;
    }
  }
  
}
```

防抖函数
```js
function debounce(fn, delay, immediate) {
  let timer = null;

  return function() {
    const context = this
    const args = arguments
    timer && clearTimeout(timer)
    if(immediate) {
      const doNow = !timer
      timer = setTimeout(() => {
        timer = null
      }, delay)
      doNow && fn.apply(context, args)
    }
    else {
      timer = setTimeout(() => {
        fn.apply(context, args)
      }, delay)
    }
  };
}
```