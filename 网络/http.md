业内普遍的分层方式有两种。OSI七层模型 和TCP/IP四层模型。
OSI七层模型：物、数、网、传、会、表、应
+ 应用层
+ 表示层
+ 会话层
+ 传输层
+ 网络层
+ 数据链路层
+ 物理层

TCP/IP四层模型：链、网、传、应
+ 应用层(http)
+ 传输层(TCP)
+ 链路层
+ 网络层

> tcp 面向**连接**的可靠的传输协议

> UDP是面向报文的
+ UDP是一个非连接的协议，传输数据之前源端和终端不建立连接

c ->   SYN   -> s

c <- SYN+ACk <- s

c ->   ACK   -> s

在内存里开辟资源(queue空间socket),为对方服务

### 三次握手四次挥手

三次握手：
1. 主动发起请求端， 发送 SYN
2. 被动建立连接请求端 ， 应答ACK 同时 发送 SYN
3. 主动发起请求端，发送应答 ACK
* 标志 TCP 三次握手建立完成。 —— server：Accept() 返回 。— client：Dial() 返回。

四次挥手：
1. 主动关闭连接请求端， 发送 FIN
2. 被动关闭连接请求端 ，应答 ACK
标志。半关闭完成。 —— close()
3. 被动关闭连接请求端 ，发送 FIN
4.  主动关闭连接请求端，应答 ACK
标志。四次挥手建立完成。 —— close().


> [TCP博客](https://www.cnblogs.com/shineyoung/p/10656914.html)

SYN：长1位，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,SYN置1就表示这是一个连接请求或连接接受报文。
ACK：长1位，置位表示确认号字段有效；TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，
在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，
在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。
但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。
所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，
不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。



1. DNS解析(网址 =-> IP地址)
 采用递归查询
+ 浏览器缓存
+ 操作系统缓存(hosts)
+ 本地域名服务器
    + 根服务器
    + 顶级域名服务器服务器
    + 权威域名服务器


> 自上而下 下载|| 渲染   css并行 图片异步  js挂起

#### get post区别
1. get要比post快
2. get有长度限制
3. get可以被url记录

GET /zoos：列出所有动物园
POST /zoos：新建一个动物园
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园

RESTful API
使用链接关联相关资源，然后通过同的请求方式对链接进行操作


### 从输入 url 到展示的过程

DNS 解析

+ TCP 三次握手
+ 发送请求，分析 url，设置请求报文(头，主体)
+ 服务器返回请求的文件 (html)
+ 浏览器渲染
    + HTML parser --> DOM Tree
        + 标记化算法，进行元素状态的标记
        + dom 树构建
    + CSS parser --> Style Tree
        + 解析 css 代码，生成样式树
    + attachment --> Render Tree
    + 结合 dom树 与 style树，生成渲染树
    + layout: 布局
    + GPU painting: 像素绘制页面

TCP拥塞
> 拥塞窗口值cwnd 慢开始门限值ssthresh

网络中某一资源的需求超过了该资源所能提供的可用部分,网络性能就要变坏. 网络会成抛物线,越多吞吐量会变小

+ 慢开始 --- 小于慢开始门限制
    + 拥塞窗口,拥塞窗口被初始化为1个报文段,当与另一个网络的主机建立TCP连接时,拥塞窗口就翻倍
+ 拥塞避免
    + 每个传输轮次拥塞窗口cwnd加1
    + 当重传计时器超时,网络很可能出现了拥塞
        + 将慢开始门限值sshthresh更新为发生拥塞时 `拥塞窗口` cwnd的一半
        + 将`拥塞窗口cwnd`减小为1,并从头执行慢开始算法
+ 快重传
    + 拥塞窗口减半cwnd=cwnd/2
    + 慢开始门限ssthresh=cwnd（减半后的值）
+ 快恢复
    + 设置cwnd = ssthresh＋ack(3)个数


### HTTP 1.0/1.1/2.0区别
HTTP 1.1

+ HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
+ HTTP1.1支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是还
  需要根据请求的顺序返回数据(一般不会启用.有很多问题,默认关闭的)
+ host 字段指定对应的虚拟站点
+ cache 缓存

HTTP 2.0

+ 二进制分帧：HTTP 2 采用二进制格式传输数据，而非HTTP 1.x 的文本格式，二进制协议解析起来更高效。
+ 多路复用：HTTP 2 同域名下所有通信都在单个连接上完成。
+ 头部压缩：只发送头部数据的差异数据，而不是全部发送，减少头部的信息量
+ 服务端推送：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。


defer和async是什么，有什么区别

defer：异步加载脚本，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后。

async：同样是异步加载脚本，区别是脚本加载完毕后立刻执行，这导致async属性下的脚本是乱序的，对于script有先后依赖关系的情况，并不适用。


“PreFlight”（也就是Option请求），用来让服务端返回允许的方法（如get、post），被跨域访问的Origin（来源，或者域），还有是否需要Credentials(认证信息）

## HTTPS
HTTPS = HTTP + TLS/SSL

信息篡改  -> 信息加密
信息窃听  -> 完整性校验
信息劫持  -> 身份验证

HTTP
SSL OR TLS
TCP
IP

主要依赖三种算法: 散列函数 Hash、对称加密和非对称加密

### 非对称加密
算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开
通过服务器掌握的私钥可以实现一对多通信

> 结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。

1. 建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
2. Web服务器利用自己的私钥解密出会话密钥。
3. Web服务器利用会话密钥加密与客户端之间的通信。